import React, { useCallback, useEffect, useRef, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  RefreshControl,
  Image,
} from "react-native";
import Header from "../../../app/components/Header";
import { LaundryMachine } from "../../../types/types";
import {
  getLaundryMachine,
  getLaundryMachinesQuery,
  updateLaundryMachine,
  getTenant,
} from "../../../firebase/firestore/firestore";
import { getAuth } from "firebase/auth";
import { onSnapshot, Timestamp } from "firebase/firestore";
import { TimerPickerModal } from "react-native-timer-picker";
import { LinearGradient } from "expo-linear-gradient";
import SubmitButton from "../../../app/components/buttons/SubmitButton";
import { appStyles } from "../../../styles/styles";
import * as Notifications from 'expo-notifications';

// portions of this code were generated by chatGPT as an AI assistant
const useTimerManagement = (residenceId: string, userId?: string) => {
  const [remainingTimes, setRemainingTimes] = useState<{
    [key: string]: string;
  }>({});

  // Use a ref to track timer references more precisely
  const timerRefsRef = useRef<{
    [key: string]: {
      intervalId?: NodeJS.Timeout;
      notificationId?: string;  // NEW - Stores notification ID instead of boolean
          }
  }>({});

  const cleanupTimer = useCallback(async (machineId: string) => {
    const timerRefs = timerRefsRef.current;
    
    if (timerRefs[machineId]?.intervalId) {
      clearInterval(timerRefs[machineId].intervalId);
      
      // NEW - Added notification cancellation
      if (timerRefs[machineId].notificationId) {
        await Notifications.cancelScheduledNotificationAsync(timerRefs[machineId].notificationId);
      }
      
      delete timerRefs[machineId];
    }

    // Ensure the remaining time is reset
    setRemainingTimes(prev => {
      const updated = {...prev};
      delete updated[machineId];
      return updated;
    });
  }, []);

  const ensureNotificationPermissions = async () => {
    const { status } = await Notifications.getPermissionsAsync() || {};
    if (status !== 'granted') {
      const { status: newStatus } = await Notifications.requestPermissionsAsync() || {};
      if (newStatus !== 'granted') {
        alert('Notification permissions are required to use this feature.');
        return false;
      }
    }
    return true;
  };

  const scheduleFinishNotification = async (machineId: string, delayS: number) => {
    const hasPermission = await ensureNotificationPermissions();
    
    if (!hasPermission) {
      console.warn('Notification scheduling aborted due to lack of permissions.');
      return;
    }
    
    if (delayS >= 0) {
      const notificationId = await Notifications.scheduleNotificationAsync({
        content: {
          title: `Laundry Machine ${machineId}`,
          body: `Your laundry will be ready in 3 minutes!`,
        },
        trigger: { seconds: delayS },
      });
      console.log(`Notification scheduled for ${delayS} seconds from now.`);
      return notificationId;  // NEW - Return the notification ID
    } else {
      console.warn('Notification time is in the past. Not scheduling.');
      return null;
    }
  };

  const calculateTimer = useCallback(
    async (
      laundryMachineId: string, 
      estimatedFinishTime: Timestamp,
      onNotificationScheduled?: () => Promise<void>
    ) => {
      // Prevent multiple timers for the same machine
      if (timerRefsRef.current[laundryMachineId]?.intervalId) {
        //console.log(`Timer already exists for machine ${laundryMachineId}`);
        return;
      }

      // Safety check for finish time
      const finishTimeMs = estimatedFinishTime.toMillis();
      if (finishTimeMs <= Date.now()) {
        console.warn(`Finish time is in the past for machine ${laundryMachineId}`);
        cleanupTimer(laundryMachineId);
        return;
      }

      // Create a new timer reference
      timerRefsRef.current[laundryMachineId] = {};

      const intervalId = setInterval(async () => {
        const currentTime = Date.now();
        const remainingTimeMs = finishTimeMs - currentTime;

        // Check if timer has expired
        if (remainingTimeMs <= 0) {
          cleanupTimer(laundryMachineId);
          
          // Update remaining times to show cycle completed
          setRemainingTimes(prev => ({
            ...prev,
            [laundryMachineId]: "Cycle completed"
          }));

          return;
        }

        // Calculate time components
        const hours = Math.floor((remainingTimeMs / (1000 * 60 * 60)) % 24);
        const minutes = Math.floor((remainingTimeMs / (1000 * 60)) % 60);
        const seconds = Math.floor((remainingTimeMs / 1000) % 60);

        // Format the remaining time
        const formattedTime = `${hours}h ${minutes}m ${seconds}s`;

        // Update remaining times
        setRemainingTimes(prev => ({
          ...prev,
          [laundryMachineId]: formattedTime
        }));

        // Schedule 3-minute notification if not already done
        const timerRef = timerRefsRef.current[laundryMachineId] || {};
        if (!timerRef.notificationId && remainingTimeMs > 3 * 60 * 1000) {
          try {
            const notificationId = await scheduleFinishNotification(
              laundryMachineId, 
              (remainingTimeMs - 3 * 60 * 1000) / 1000
            );
            
            if (notificationId) {
              timerRef.notificationId = notificationId;
              await onNotificationScheduled?.();
            }
          }
        catch (error) {
          console.error(`Notification scheduling failed for ${laundryMachineId}`, error);
        }
      }
      }, 1000);

      // Store the interval ID
      timerRefsRef.current[laundryMachineId].intervalId = intervalId;
    }, 
    [cleanupTimer]
  );

  // Cleanup all timers when component unmounts
  useEffect(() => {
    return () => {
      Object.keys(timerRefsRef.current).forEach(cleanupTimer);
    };
  }, [cleanupTimer]);

  return {
    remainingTimes,
    calculateTimer,
    cleanupTimer
  };
};

const WashingMachineScreen = () => {
  const [machines, setMachines] = useState<LaundryMachine[]>([]);
  const [isTimerModalVisible, setIsTimerModalVisible] = useState(false);
  const [selectedMachineId, setSelectedMachineId] = useState<string | null>(null);
  const [refreshing, setRefreshing] = useState(false);
  const [residenceId, setResidenceId] = useState<string>("");

  // Initialize auth instance
  const auth = getAuth();
  const user = auth.currentUser;
  const userId = user ? user.uid : undefined;

  // Add useEffect to fetch tenant's residence
  useEffect(() => {
    const fetchTenantResidence = async () => {
      if (!userId) return;
      
      try {
        const tenantDoc = await getTenant(userId);
        if (tenantDoc && tenantDoc.residenceId) {
          setResidenceId(tenantDoc.residenceId);
        }
      } catch (error) {
        console.error("Error fetching tenant's residence:", error);
      }
    };

    fetchTenantResidence();
  }, [userId]);

  // Use the custom timer management hook
  const { 
    remainingTimes, 
    calculateTimer, 
    cleanupTimer 
  } = useTimerManagement(residenceId, userId);

  // Update fetchMachines to only fetch if we have a residenceId
  const fetchMachines = useCallback(async () => {
    if (!residenceId) return () => {};
    
    setRefreshing(true);
    try {
      const query = getLaundryMachinesQuery(residenceId);
      
      return onSnapshot(query, (querySnapshot) => {
        const updatedMachines: LaundryMachine[] = [];
        
        querySnapshot.forEach((doc) => {
          const machineData = doc.data() as LaundryMachine;
          updatedMachines.push({
            ...machineData,
            laundryMachineId: doc.id
          });
        });
        
        setMachines(updatedMachines);
        
        // Restart timers for machines that are in use
        updatedMachines.forEach((machine) => {
          if (machine.estimatedFinishTime && !machine.isAvailable) {
            calculateTimer(machine.laundryMachineId, machine.estimatedFinishTime);
          }
        });
      });
    } catch (error) {
      console.error("Error fetching washing machines:", error);
      return () => {};
    } finally {
      setRefreshing(false);
    }
  }, [residenceId, calculateTimer]);

  useEffect(() => {
    let unsubscribe: (() => void) | undefined;
    
    const setup = async () => {
      unsubscribe = await fetchMachines();
    };
    
    setup();

    return () => {
      unsubscribe?.();
    };
  }, [fetchMachines]);

  useEffect(() => {
    Notifications.setNotificationHandler({
      handleNotification: async () => ({
        shouldShowAlert: true,
        shouldPlaySound: true,
        shouldSetBadge: false,
      }),
    });
    console.log("Notification handler set");
  }, []); // Empty dependency array ensures this runs only once when the screen is mounted


  const handleSetTimer = (pickedDuration: Date) => {
    if (selectedMachineId) {
      const startTime = Timestamp.now();
      const durationMs =
        pickedDuration.getHours() * 3600 * 1000 +
        pickedDuration.getMinutes() * 60 * 1000 +
        pickedDuration.getSeconds() * 1000;
      const estimatedFinishTime = Timestamp.fromMillis(
        startTime.toMillis() + durationMs
      );
      
      // First update Firebase with the machine status
    const updateMachine = async () => {
      await updateLaundryMachine(residenceId, selectedMachineId, {
        occupiedBy: userId,
        isAvailable: false,
        startTime,
        estimatedFinishTime
      });
    };

      calculateTimer(
        selectedMachineId, 
        estimatedFinishTime,
        async () => {
        // Only update the notification flag if a notification was actually scheduled
        await updateLaundryMachine(residenceId, selectedMachineId, {
          notificationScheduled: true
        });
      }
      );
      // Update Firebase immediately
    updateMachine();
    }
    setIsTimerModalVisible(false);
    setSelectedMachineId(null);
  };

  const handleResetMachine = async (laundryMachineId: string) => {
    // Use cleanupTimer to ensure proper timer removal
    cleanupTimer(laundryMachineId);

    await updateLaundryMachine(residenceId, laundryMachineId, {
      isAvailable: true,
      occupiedBy: "none",
      notificationScheduled: false
    });
  };

  const getStatus = (machine: LaundryMachine) => {
    if (!machine.isFunctional) {
      return {
        statusText: "Under Maintenance",
        style: styles.underMaintenanceBubble,
      };
    }
    return machine.isAvailable
      ? { statusText: "Available", style: styles.availableBubble }
      : { statusText: "In Use", style: styles.inUseBubble };
  };

  const renderMachines = () => {
    return machines.map((machine) => {
      const { statusText, style } = getStatus(machine);

      return (
        <View key={machine.laundryMachineId} style={styles.machineCard}>
          <View style={{ flexDirection: "row" }}>
            <Image
              // eslint-disable-next-line @typescript-eslint/no-require-imports
              source={require("../../../assets/images/washing_machine_icon_png.png")}
              style={{ width: 120, height: 120, marginRight: 20 }}
            />
            <View
              style={{
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
              }}
            >
              <Text style={styles.machineTitle}>
                Machine {machine.laundryMachineId}
              </Text>
              <View style={[styles.statusBubble, style]}>
                <Text style={styles.statusText}>{statusText}</Text>
              </View>

              {/* Placeholder View for consistent layout */}
              <View
                style={{
                  marginTop: 10,
                  marginBottom: 10,
                  alignItems: "center",
                  gap: 10,
                }}
              >
                {machine.isAvailable && machine.isFunctional && (
                  <SubmitButton
                    width={150}
                    height={40}
                    disabled={false}
                    textStyle={{ fontSize: 16 }}
                    style={appStyles.submitButton}
                    testID="setTimerButton"
                    label="Set Timer"
                    onPress={() => {
                      setSelectedMachineId(machine.laundryMachineId);
                      setIsTimerModalVisible(true);
                    }}
                  />
                )}
                {!machine.isAvailable && (
                  <Text style={styles.remainingTime}>
                    {remainingTimes[machine.laundryMachineId] ||
                      "Calculating..."}
                  </Text>
                )}

                {/* Reset button, shown only when cycle is complete */}
                {!machine.isAvailable &&
                  remainingTimes[machine.laundryMachineId] ===
                    "Cycle completed" &&
                  machine.occupiedBy === userId && ( // Only show if the user started the cycle
                    <SubmitButton
                      width={200}
                      height={40}
                      textStyle={{ fontSize: 16 }}
                      style={appStyles.submitButton}
                      testID={`${machine.laundryMachineId}-unlock-button`}
                      label="Unlock"
                      onPress={() =>
                        handleResetMachine(machine.laundryMachineId)
                      }
                      disabled={false}
                    />
                  )}

                {/* Cancel Timer button, shown only when the timer is active */}
                {!machine.isAvailable &&
                  machine.occupiedBy === userId && // Only show if the user started the timer
                  remainingTimes[machine.laundryMachineId] !==
                    "Cycle completed" && (
                    <SubmitButton
                      width={200}
                      height={40}
                      textStyle={{ fontSize: 16 }}
                      style={appStyles.submitButton}
                      testID={`${machine.laundryMachineId}-cancel-button`}
                      label="Cancel Timer"
                      onPress={() =>
                        handleResetMachine(machine.laundryMachineId)
                      }
                      disabled={false}
                    />
                  )}
              </View>
            </View>
          </View>
        </View>
      );
    });
  };

  return (
    <>
      <Header>
        <View testID="washing-machine-screen" style={styles.container}>
          <Text style={styles.title}>Laundry Machines</Text>
          <ScrollView
            testID="scroll-view"
            contentContainerStyle={machines.length === 0 && styles.centeredContent}
            refreshControl={
              <RefreshControl
                refreshing={refreshing}
                onRefresh={fetchMachines}
              />
            }
          >
            {machines.length === 0 ? (
              <Text style={styles.noMachinesText}>
                No washing machines available
              </Text>
            ) : (
              renderMachines()
            )}
          </ScrollView>
          <TimerPickerModal
            visible={isTimerModalVisible}
            setIsVisible={setIsTimerModalVisible}
            onConfirm={(pickedDuration) => {
              const timestamp_duration = new Date(
                0,
                0,
                0,
                pickedDuration.hours,
                pickedDuration.minutes,
                pickedDuration.seconds
              );
              handleSetTimer(timestamp_duration);
              setIsTimerModalVisible(false);
            }}
            modalTitle="Choose Washing Duration"
            onCancel={() => setIsTimerModalVisible(false)}
            closeOnOverlayPress
            LinearGradient={LinearGradient}
            styles={{
              theme: "light",
            }}
          />
        </View>
      </Header>
    </>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 0.69,
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontFamily: "Inter", // Make sure Inter font is loaded in your project
    fontWeight: "bold",
    marginBottom: 20,
  },
  remainingTime: {
    fontSize: 16,
    color: "#333",
    marginTop: 5,
  },
  machineCard: {
    backgroundColor: "#f5f5f5",
    padding: 15,
    borderRadius: 25,
    marginBottom: 10,
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.1,
  },
  machineTitle: {
    fontSize: 20,
    color: "#0F5257",
    fontWeight: "600",
  },
  statusBubble: {
    paddingVertical: 5,
    paddingHorizontal: 15,
    borderRadius: 15,
    marginTop: 5,
    alignItems: "center",
    justifyContent: "center",
  },
  statusText: {
    color: "#fff",
    fontWeight: "bold",
    fontSize: 16,
    textAlign: "center",
  },
  availableBubble: {
    backgroundColor: "green",
  },
  inUseBubble: {
    backgroundColor: "orange",
  },
  underMaintenanceBubble: {
    backgroundColor: "red",
  },
  centeredContent: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  noMachinesText: {
    fontSize: 18,
    color: "gray",
    textAlign: "center",
  },
});

export default WashingMachineScreen;