import React from "react";
import { render, fireEvent, act, waitFor, within } from "@testing-library/react-native";
import WashingMachineScreen from "../../screens/laundry_machines/WashingMachineScreen";
import * as Notifications from "expo-notifications";
import { getAllLaundryMachines, getLaundryMachinesQuery, updateLaundryMachine } from "../../../firebase/firestore/firestore";
import { NotificationPermissionsStatus } from "expo-notifications";

// portions of this code were generated by chatGPT as an AI assistant

// Mock Firestore functions
jest.mock("../../../firebase/firestore/firestore", () => ({
    getLaundryMachinesQuery: jest.fn(),
    updateLaundryMachine: jest.fn(),
    getLaundryMachine: jest.fn(() =>
        Promise.resolve({
          laundryMachineId: "coucou",
          isAvailable: true,
          isFunctional: true,
          occupiedBy: "none",
          startTime: { toMillis: () => Date.now() },
          estimatedFinishTime: { toMillis: () => Date.now() + 3600000 }, // 1 hour from now
          notificationScheduled: false,
        })
      ),
}));

jest.mock('expo-notifications', () => ({
    getPermissionsAsync: jest.fn(() => Promise.resolve({ status: 'granted' })),
    requestPermissionsAsync: jest.fn(() => Promise.resolve({ status: 'granted' })),
    scheduleNotificationAsync: jest.fn(() => Promise.resolve('mocked-notification-id')), // Fix here
    setNotificationHandler: jest.fn(() => {}),
  }));
  
    
jest.mock('firebase/firestore', () => {
const actualFirestore = jest.requireActual('firebase/firestore');

return {
    ...actualFirestore, // Include the actual implementations for non-mocked parts
    Timestamp: {
    now: jest.fn(() => ({
        toMillis: jest.fn(() => Date.now()),
    })),
    fromMillis: jest.fn((millis) => ({
        toMillis: jest.fn(() => millis),
    })),
    },
    onSnapshot: jest.fn((query, callback) => {
    const mockSnapshot = {
        forEach: (fn: (arg0: {
        id: string;
        data: () => {
            laundryMachineId: string;
            isAvailable: boolean;
            isFunctional: boolean;
            occupiedBy: string;
            startTime: ReturnType<typeof actualFirestore.Timestamp.now>;
            estimatedFinishTime: ReturnType<typeof actualFirestore.Timestamp.fromMillis>;
            notificationScheduled: boolean;
        };
        }) => void) => {
        fn({
            id: 'coucou',
            data: () => ({
            laundryMachineId: 'coucou',
            isAvailable: true,
            isFunctional: true,
            occupiedBy: 'none',
            startTime: actualFirestore.Timestamp.now(),
            estimatedFinishTime: actualFirestore.Timestamp.fromMillis(Date.now() + 3600000), // 1 hour from now
            notificationScheduled: false,
            }),
        });
        },
    };

    // Call the callback with the mock snapshot
    callback(mockSnapshot);

    // Return an unsubscribe function
    return () => {};
    }),
};
});  
  
  jest.mock('expo-linear-gradient', () => ({
    LinearGradient: jest.fn().mockImplementation(({ children }) => children),
  }));
  
  jest.mock('@react-navigation/native', () => ({
    ...jest.requireActual('@react-navigation/native'),
    useNavigation: () => ({
      navigate: jest.fn(),
      goBack: jest.fn(),
    }),
  }));
  

describe("WashingMachineScreen - Notifications", () => {
  beforeEach(() => {
    jest.useFakeTimers();
    jest.clearAllMocks();
    global.alert = jest.fn();

// Setup mock for getLaundryMachinesQuery to return a query
(getLaundryMachinesQuery as jest.Mock).mockReturnValue({});

// Mock auth to provide a user
jest.spyOn(require("firebase/auth"), "getAuth").mockReturnValue({
  currentUser: { uid: 'testUser' }
});  });

afterEach(() => {
    jest.runOnlyPendingTimers();
    jest.useRealTimers();
  });

  it("renders the washing machine fetched from Firestore", async () => {
  
    const { getByText } = render(<WashingMachineScreen />);
  
    // Wait for async rendering
    await act(async () => {});
  
    await waitFor(() => {expect(getByText("Machine coucou")).toBeTruthy()});
  });

  it("does not schedule a notification if permissions are denied", async () => {
    // Mock denied permissions
    (Notifications.getPermissionsAsync as jest.Mock).mockResolvedValueOnce({
      status: "denied",
    } as NotificationPermissionsStatus);
    (Notifications.requestPermissionsAsync as jest.Mock).mockResolvedValueOnce({
      status: "denied",
    } as NotificationPermissionsStatus);

    const { getByText, getByTestId } = render(<WashingMachineScreen />);

    // Verify that the placeholder machine is rendered
    expect(getByText("Machine coucou")).toBeTruthy();

    // Simulate setting a timer
    const button = getByTestId("setTimerButton");
    await act(async () => {
      fireEvent.press(button);
    });

    // Step 2: Simulate confirming a duration of 5 minutes
    const modal = getByTestId("timer-picker-modal");
    await act(async () => {
        fireEvent(modal, "onConfirm", { hours: 0, minutes: 5, seconds: 0 }); // Mock time selection
    });

    expect(Notifications.scheduleNotificationAsync).not.toHaveBeenCalled();
    expect(alert).toHaveBeenCalledWith('Notification permissions are required to use this feature.');
  });

  it("schedules a notification if permissions are granted", async () => {
    // Mock granted permissions
    (Notifications.getPermissionsAsync as jest.Mock).mockResolvedValueOnce({
        status: "granted",
      } as NotificationPermissionsStatus);
  
      const { getByText, getByTestId } = render(<WashingMachineScreen />);
  
      // Verify that the placeholder machine is rendered
      expect(getByText("Machine coucou")).toBeTruthy();
  
      // Simulate setting a timer
      const button = getByTestId("setTimerButton");
      await act(async () => {
        fireEvent.press(button);
      });
  
      // Step 2: Simulate confirming a duration of 5 minutes
      const modal = getByTestId("timer-picker-modal");
        await act(async () => {
            fireEvent(modal, "onConfirm", { hours: 0, minutes: 5, seconds: 0 }); // Mock time selection
        });

        expect(getByText("Machine coucou")).toBeTruthy();
        expect(Notifications.scheduleNotificationAsync)
        .toHaveBeenCalledWith({
      content: {
        title: `Laundry Machine coucou`,
        body: "Your laundry will be ready in 3 minutes!",
      },
      trigger: { seconds: 2*60 },
    });
  });

  it("does not schedule a notification for past times", async () => {
    // Mock permissions granted
    (Notifications.getPermissionsAsync as jest.Mock).mockResolvedValueOnce({
      status: "granted",
    } as NotificationPermissionsStatus);

    const { getByText, getByTestId } = render(<WashingMachineScreen />);
  
    // Verify that the placeholder machine is rendered
    expect(getByText("Machine coucou")).toBeTruthy();

    // Simulate setting a timer
    const button = getByTestId("setTimerButton");
    await act(async () => {
    fireEvent.press(button);
    });

    // Step 2: Simulate confirming a duration of 5 minutes
    const modal = getByTestId("timer-picker-modal");
    await act(async () => {
        fireEvent(modal, "onConfirm", { hours: 0, minutes: 2, seconds: 0 }); // Mock time selection
    });

    expect(Notifications.scheduleNotificationAsync).not.toHaveBeenCalledWith(
      expect.objectContaining({
        trigger: { seconds: expect.any(Number) },
      })
    );
  });

  it("updates Firestore after scheduling a notification", async () => {
    // Mock permissions granted
    (Notifications.getPermissionsAsync as jest.Mock).mockResolvedValueOnce({
      status: "granted",
    } as NotificationPermissionsStatus);

    const { getByText, getByTestId } = render(<WashingMachineScreen />);
  
      // Verify that the placeholder machine is rendered
      expect(getByText("Machine coucou")).toBeTruthy();
  
      // Simulate setting a timer
      const button = getByTestId("setTimerButton");
      await act(async () => {
        fireEvent.press(button);
      });
  
      // Step 2: Simulate confirming a duration of 5 minutes
      const modal = getByTestId("timer-picker-modal");
      await act(async () => {
          fireEvent(modal, "onConfirm", { hours: 0, minutes: 5, seconds: 0 }); // Mock time selection
      });

      await waitFor(() => {
        expect(updateLaundryMachine).toHaveBeenCalledWith(
          expect.any(String),
          expect.any(String),
          expect.objectContaining({
            notificationScheduled: true,
          })
        );
      }, { timeout: 3000 });
  });
});
